# Import libraries
import os
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.layers import *
from tensorflow.keras.models import Sequential
from tensorflow.keras.preprocessing import image
from tensorflow.keras.preprocessing.image import ImageDataGenerator
import warnings

warnings.filterwarnings('ignore')


# Logging function
def log_message(message):
    print(f"[LOG] {message}")


# Verify directory paths
def verify_directory_structure():
    log_message("Verifying directory structure...")
    paths = {
        "Train": "Vegetable Images/train",
        "Validation": "Vegetable Images/validation",
        "Test": "Vegetable Images/test"
    }

    for path_name, path in paths.items():
        if not os.path.exists(path):
            log_message(f"❌ {path_name} directory does not exist: {path}")
            return False

        log_message(f"✅ {path_name} directory exists: {path}")

        # Count images in each category
        for category in os.listdir(path):
            category_path = os.path.join(path, category)
            image_count = len([f for f in os.listdir(category_path) if f.lower().endswith(('.png', '.jpg', '.jpeg'))])
            log_message(f"   - {category}: {image_count} images")

    return True


# Verify model can read images
def test_image_generators():
    log_message("Testing image generators...")

    try:
        train_gen = ImageDataGenerator(rescale=1.0 / 255.0)
        train_image_generator = train_gen.flow_from_directory(
            "Vegetable Images/train",
            target_size=(150, 150),
            batch_size=32,
            class_mode='categorical')
        log_message(f"✅ Train generator created successfully")
        log_message(f"Classes detected: {train_image_generator.class_indices}")
    except Exception as e:
        log_message(f"❌ Train generator failed: {e}")
        return False

    try:
        val_gen = ImageDataGenerator(rescale=1.0 / 255.0)
        val_image_generator = val_gen.flow_from_directory(
            "Vegetable Images/validation",
            target_size=(150, 150),
            batch_size=32,
            class_mode='categorical')
        log_message(f"✅ Validation generator created successfully")
    except Exception as e:
        log_message(f"❌ Validation generator failed: {e}")
        return False

    try:
        test_gen = ImageDataGenerator(rescale=1.0 / 255.0)
        test_image_generator = test_gen.flow_from_directory(
            "Vegetable Images/test",
            target_size=(150, 150),
            batch_size=32,
            class_mode='categorical')
        log_message(f"✅ Test generator created successfully")
    except Exception as e:
        log_message(f"❌ Test generator failed: {e}")
        return False

    return True


# Build model with more logging
def build_and_compile_model(num_classes):
    log_message("Building CNN model...")

    model = Sequential([
        Conv2D(filters=32, kernel_size=3, strides=1, padding='same', activation='relu', input_shape=[150, 150, 3]),
        MaxPooling2D(2),
        Conv2D(filters=64, kernel_size=3, strides=1, padding='same', activation='relu'),
        MaxPooling2D(2),
        Flatten(),
        Dense(128, activation='relu'),
        Dropout(0.25),
        Dense(128, activation='relu'),
        Dense(num_classes, activation='softmax')
    ])

    log_message("Model summary:")
    model.summary()

    log_message("Compiling model...")
    model.compile(
        optimizer='Adam',
        loss='categorical_crossentropy',
        metrics=['accuracy']
    )

    return model


# Save model and class mapping
def save_model_and_metadata(model, train_image_generator):
    # Create a directory to store model and metadata
    save_dir = "vegetable_classification_model"
    os.makedirs(save_dir, exist_ok=True)

    # Save the model
    model_path = os.path.join(save_dir, "vegetable_model.keras")
    model.save(model_path)
    log_message(f"✅ Model saved to {model_path}")

    # Save class indices
    import json
    class_indices_path = os.path.join(save_dir, "class_indices.json")
    with open(class_indices_path, 'w') as f:
        json.dump(train_image_generator.class_indices, f)
    log_message(f"✅ Class indices saved to {class_indices_path}")


# Main execution
def main():
    log_message("Starting Vegetable Classification Pipeline")

    # Verify directory structure
    if not verify_directory_structure():
        log_message("❌ Directory structure verification failed. Exiting.")
        return

    # Test image generators
    if not test_image_generators():
        log_message("❌ Image generator test failed. Exiting.")
        return

    # Prepare data generators
    log_message("Preparing data generators...")
    train_gen = ImageDataGenerator(rescale=1.0 / 255.0)
    train_image_generator = train_gen.flow_from_directory(
        "Vegetable Images/train",
        target_size=(150, 150),
        batch_size=32,
        class_mode='categorical')

    val_gen = ImageDataGenerator(rescale=1.0 / 255.0)
    val_image_generator = val_gen.flow_from_directory(
        "Vegetable Images/validation",
        target_size=(150, 150),
        batch_size=32,
        class_mode='categorical')

    # Get number of classes
    num_classes = len(train_image_generator.class_indices)
    log_message(f"Number of vegetable classes detected: {num_classes}")

    # Build and compile model
    model = build_and_compile_model(num_classes)

    # Model training with extensive logging
    log_message("Starting model training...")
    early_stopping = keras.callbacks.EarlyStopping(patience=5)

    try:
        hist = model.fit(
            train_image_generator,
            epochs=10,  # Reduced for debugging
            verbose=1,
            validation_data=val_image_generator,
            callbacks=[early_stopping]
        )
        log_message("✅ Model training completed successfully")

        # Save the model and class indices
        save_model_and_metadata(model, train_image_generator)

    except Exception as e:
        log_message(f"❌ Model training failed: {e}")
        return


# Run the main pipeline
if __name__ == "__main__":
    main()
